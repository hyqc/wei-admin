// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v3.21.12
// source: admin_account.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { MenuItem } from "./admin_menu";
import { AdminUserRoleItem } from "./common";

export const protobufPackage = "admin";

/** 登录 */
export interface ReqLogin {
  /** 用户名 */
  username?:
    | string
    | undefined;
  /** 密码 */
  password?: string | undefined;
}

export interface RespLoginData {
  data?: AdminInfo | undefined;
}

/** 账号详情 */
export interface ReqAccountInfo {
  /** 刷新token */
  refreshToken?: boolean | undefined;
}

export interface RespAccountInfoData {
  data?: AdminInfo | undefined;
}

/** 账号编辑 */
export interface ReqAccountEdit {
  /** 名称 */
  nickname?:
    | string
    | undefined;
  /** 头像 */
  avatar?:
    | string
    | undefined;
  /** 邮箱 */
  email?: string | undefined;
}

export interface RespAccountEditData {
}

/** 修改密码 */
export interface ReqAccountPasswordEdit {
  /** 旧密码 */
  oldPassword?:
    | string
    | undefined;
  /** 新密码 */
  password?:
    | string
    | undefined;
  /** 确认密码 */
  confirmPassword?: string | undefined;
}

export interface RespAccountPasswordEditData {
}

/** 个人权限 */
export interface ReqAccountPermission {
  /** 菜单ID */
  menuId?: number | undefined;
}

export interface RespAccountPermissionData {
}

/** 管理员账号详情 */
export interface AdminInfo {
  adminId?: number | undefined;
  username?: string | undefined;
  nickname?: string | undefined;
  avatar?: string | undefined;
  email?: string | undefined;
  createTime?: string | undefined;
  modifyTime?: string | undefined;
  lastLoginTime?: string | undefined;
  lastLoginIp?: string | undefined;
  loginTotal?: number | undefined;
  enabled?: boolean | undefined;
  token?: string | undefined;
  expire?: number | undefined;
  expireDataTime?: string | undefined;
  menus?: { [key: string]: MenuItem } | undefined;
  permissions?: { [key: string]: string } | undefined;
  roles?: AdminUserRoleItem[] | undefined;
}

export interface AdminInfo_MenusEntry {
  key: string;
  value?: MenuItem | undefined;
}

export interface AdminInfo_PermissionsEntry {
  key: string;
  value: string;
}

function createBaseReqLogin(): ReqLogin {
  return { username: "", password: "" };
}

export const ReqLogin: MessageFns<ReqLogin> = {
  encode(message: ReqLogin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== undefined && message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== undefined && message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReqLogin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReqLogin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReqLogin {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: ReqLogin): unknown {
    const obj: any = {};
    if (message.username !== undefined && message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== undefined && message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReqLogin>, I>>(base?: I): ReqLogin {
    return ReqLogin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReqLogin>, I>>(object: I): ReqLogin {
    const message = createBaseReqLogin();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRespLoginData(): RespLoginData {
  return { data: undefined };
}

export const RespLoginData: MessageFns<RespLoginData> = {
  encode(message: RespLoginData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      AdminInfo.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespLoginData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespLoginData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = AdminInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RespLoginData {
    return { data: isSet(object.data) ? AdminInfo.fromJSON(object.data) : undefined };
  },

  toJSON(message: RespLoginData): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = AdminInfo.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RespLoginData>, I>>(base?: I): RespLoginData {
    return RespLoginData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespLoginData>, I>>(object: I): RespLoginData {
    const message = createBaseRespLoginData();
    message.data = (object.data !== undefined && object.data !== null) ? AdminInfo.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseReqAccountInfo(): ReqAccountInfo {
  return { refreshToken: false };
}

export const ReqAccountInfo: MessageFns<ReqAccountInfo> = {
  encode(message: ReqAccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== undefined && message.refreshToken !== false) {
      writer.uint32(8).bool(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReqAccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReqAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.refreshToken = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReqAccountInfo {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.Boolean(object.refreshToken) : false };
  },

  toJSON(message: ReqAccountInfo): unknown {
    const obj: any = {};
    if (message.refreshToken !== undefined && message.refreshToken !== false) {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReqAccountInfo>, I>>(base?: I): ReqAccountInfo {
    return ReqAccountInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReqAccountInfo>, I>>(object: I): ReqAccountInfo {
    const message = createBaseReqAccountInfo();
    message.refreshToken = object.refreshToken ?? false;
    return message;
  },
};

function createBaseRespAccountInfoData(): RespAccountInfoData {
  return { data: undefined };
}

export const RespAccountInfoData: MessageFns<RespAccountInfoData> = {
  encode(message: RespAccountInfoData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      AdminInfo.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespAccountInfoData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespAccountInfoData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = AdminInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RespAccountInfoData {
    return { data: isSet(object.data) ? AdminInfo.fromJSON(object.data) : undefined };
  },

  toJSON(message: RespAccountInfoData): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = AdminInfo.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RespAccountInfoData>, I>>(base?: I): RespAccountInfoData {
    return RespAccountInfoData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespAccountInfoData>, I>>(object: I): RespAccountInfoData {
    const message = createBaseRespAccountInfoData();
    message.data = (object.data !== undefined && object.data !== null) ? AdminInfo.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseReqAccountEdit(): ReqAccountEdit {
  return { nickname: "", avatar: "", email: "" };
}

export const ReqAccountEdit: MessageFns<ReqAccountEdit> = {
  encode(message: ReqAccountEdit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nickname !== undefined && message.nickname !== "") {
      writer.uint32(10).string(message.nickname);
    }
    if (message.avatar !== undefined && message.avatar !== "") {
      writer.uint32(18).string(message.avatar);
    }
    if (message.email !== undefined && message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReqAccountEdit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReqAccountEdit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReqAccountEdit {
    return {
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: ReqAccountEdit): unknown {
    const obj: any = {};
    if (message.nickname !== undefined && message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.avatar !== undefined && message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.email !== undefined && message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReqAccountEdit>, I>>(base?: I): ReqAccountEdit {
    return ReqAccountEdit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReqAccountEdit>, I>>(object: I): ReqAccountEdit {
    const message = createBaseReqAccountEdit();
    message.nickname = object.nickname ?? "";
    message.avatar = object.avatar ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseRespAccountEditData(): RespAccountEditData {
  return {};
}

export const RespAccountEditData: MessageFns<RespAccountEditData> = {
  encode(_: RespAccountEditData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespAccountEditData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespAccountEditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RespAccountEditData {
    return {};
  },

  toJSON(_: RespAccountEditData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RespAccountEditData>, I>>(base?: I): RespAccountEditData {
    return RespAccountEditData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespAccountEditData>, I>>(_: I): RespAccountEditData {
    const message = createBaseRespAccountEditData();
    return message;
  },
};

function createBaseReqAccountPasswordEdit(): ReqAccountPasswordEdit {
  return { oldPassword: "", password: "", confirmPassword: "" };
}

export const ReqAccountPasswordEdit: MessageFns<ReqAccountPasswordEdit> = {
  encode(message: ReqAccountPasswordEdit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldPassword !== undefined && message.oldPassword !== "") {
      writer.uint32(10).string(message.oldPassword);
    }
    if (message.password !== undefined && message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.confirmPassword !== undefined && message.confirmPassword !== "") {
      writer.uint32(26).string(message.confirmPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReqAccountPasswordEdit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReqAccountPasswordEdit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.confirmPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReqAccountPasswordEdit {
    return {
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      confirmPassword: isSet(object.confirmPassword) ? globalThis.String(object.confirmPassword) : "",
    };
  },

  toJSON(message: ReqAccountPasswordEdit): unknown {
    const obj: any = {};
    if (message.oldPassword !== undefined && message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.password !== undefined && message.password !== "") {
      obj.password = message.password;
    }
    if (message.confirmPassword !== undefined && message.confirmPassword !== "") {
      obj.confirmPassword = message.confirmPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReqAccountPasswordEdit>, I>>(base?: I): ReqAccountPasswordEdit {
    return ReqAccountPasswordEdit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReqAccountPasswordEdit>, I>>(object: I): ReqAccountPasswordEdit {
    const message = createBaseReqAccountPasswordEdit();
    message.oldPassword = object.oldPassword ?? "";
    message.password = object.password ?? "";
    message.confirmPassword = object.confirmPassword ?? "";
    return message;
  },
};

function createBaseRespAccountPasswordEditData(): RespAccountPasswordEditData {
  return {};
}

export const RespAccountPasswordEditData: MessageFns<RespAccountPasswordEditData> = {
  encode(_: RespAccountPasswordEditData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespAccountPasswordEditData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespAccountPasswordEditData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RespAccountPasswordEditData {
    return {};
  },

  toJSON(_: RespAccountPasswordEditData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RespAccountPasswordEditData>, I>>(base?: I): RespAccountPasswordEditData {
    return RespAccountPasswordEditData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespAccountPasswordEditData>, I>>(_: I): RespAccountPasswordEditData {
    const message = createBaseRespAccountPasswordEditData();
    return message;
  },
};

function createBaseReqAccountPermission(): ReqAccountPermission {
  return { menuId: 0 };
}

export const ReqAccountPermission: MessageFns<ReqAccountPermission> = {
  encode(message: ReqAccountPermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.menuId !== undefined && message.menuId !== 0) {
      writer.uint32(8).int32(message.menuId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReqAccountPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReqAccountPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.menuId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReqAccountPermission {
    return { menuId: isSet(object.menuId) ? globalThis.Number(object.menuId) : 0 };
  },

  toJSON(message: ReqAccountPermission): unknown {
    const obj: any = {};
    if (message.menuId !== undefined && message.menuId !== 0) {
      obj.menuId = Math.round(message.menuId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReqAccountPermission>, I>>(base?: I): ReqAccountPermission {
    return ReqAccountPermission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReqAccountPermission>, I>>(object: I): ReqAccountPermission {
    const message = createBaseReqAccountPermission();
    message.menuId = object.menuId ?? 0;
    return message;
  },
};

function createBaseRespAccountPermissionData(): RespAccountPermissionData {
  return {};
}

export const RespAccountPermissionData: MessageFns<RespAccountPermissionData> = {
  encode(_: RespAccountPermissionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespAccountPermissionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespAccountPermissionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RespAccountPermissionData {
    return {};
  },

  toJSON(_: RespAccountPermissionData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RespAccountPermissionData>, I>>(base?: I): RespAccountPermissionData {
    return RespAccountPermissionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespAccountPermissionData>, I>>(_: I): RespAccountPermissionData {
    const message = createBaseRespAccountPermissionData();
    return message;
  },
};

function createBaseAdminInfo(): AdminInfo {
  return {
    adminId: 0,
    username: "",
    nickname: "",
    avatar: "",
    email: "",
    createTime: "",
    modifyTime: "",
    lastLoginTime: "",
    lastLoginIp: "",
    loginTotal: 0,
    enabled: false,
    token: "",
    expire: 0,
    expireDataTime: "",
    menus: {},
    permissions: {},
    roles: [],
  };
}

export const AdminInfo: MessageFns<AdminInfo> = {
  encode(message: AdminInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adminId !== undefined && message.adminId !== 0) {
      writer.uint32(8).int32(message.adminId);
    }
    if (message.username !== undefined && message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.nickname !== undefined && message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.avatar !== undefined && message.avatar !== "") {
      writer.uint32(34).string(message.avatar);
    }
    if (message.email !== undefined && message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.createTime !== undefined && message.createTime !== "") {
      writer.uint32(50).string(message.createTime);
    }
    if (message.modifyTime !== undefined && message.modifyTime !== "") {
      writer.uint32(58).string(message.modifyTime);
    }
    if (message.lastLoginTime !== undefined && message.lastLoginTime !== "") {
      writer.uint32(66).string(message.lastLoginTime);
    }
    if (message.lastLoginIp !== undefined && message.lastLoginIp !== "") {
      writer.uint32(74).string(message.lastLoginIp);
    }
    if (message.loginTotal !== undefined && message.loginTotal !== 0) {
      writer.uint32(80).int32(message.loginTotal);
    }
    if (message.enabled !== undefined && message.enabled !== false) {
      writer.uint32(88).bool(message.enabled);
    }
    if (message.token !== undefined && message.token !== "") {
      writer.uint32(98).string(message.token);
    }
    if (message.expire !== undefined && message.expire !== 0) {
      writer.uint32(104).int64(message.expire);
    }
    if (message.expireDataTime !== undefined && message.expireDataTime !== "") {
      writer.uint32(114).string(message.expireDataTime);
    }
    Object.entries(message.menus || {}).forEach(([key, value]) => {
      AdminInfo_MenusEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    Object.entries(message.permissions || {}).forEach(([key, value]) => {
      AdminInfo_PermissionsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.roles !== undefined && message.roles.length !== 0) {
      for (const v of message.roles) {
        AdminUserRoleItem.encode(v!, writer.uint32(138).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.adminId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modifyTime = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastLoginTime = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lastLoginIp = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.loginTotal = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.expire = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.expireDataTime = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = AdminInfo_MenusEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.menus![entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = AdminInfo_PermissionsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.permissions![entry16.key] = entry16.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          const el = AdminUserRoleItem.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.roles!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminInfo {
    return {
      adminId: isSet(object.adminId) ? globalThis.Number(object.adminId) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "",
      modifyTime: isSet(object.modifyTime) ? globalThis.String(object.modifyTime) : "",
      lastLoginTime: isSet(object.lastLoginTime) ? globalThis.String(object.lastLoginTime) : "",
      lastLoginIp: isSet(object.lastLoginIp) ? globalThis.String(object.lastLoginIp) : "",
      loginTotal: isSet(object.loginTotal) ? globalThis.Number(object.loginTotal) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expire: isSet(object.expire) ? globalThis.Number(object.expire) : 0,
      expireDataTime: isSet(object.expireDataTime) ? globalThis.String(object.expireDataTime) : "",
      menus: isObject(object.menus)
        ? Object.entries(object.menus).reduce<{ [key: string]: MenuItem }>((acc, [key, value]) => {
          acc[key] = MenuItem.fromJSON(value);
          return acc;
        }, {})
        : {},
      permissions: isObject(object.permissions)
        ? Object.entries(object.permissions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => AdminUserRoleItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: AdminInfo): unknown {
    const obj: any = {};
    if (message.adminId !== undefined && message.adminId !== 0) {
      obj.adminId = Math.round(message.adminId);
    }
    if (message.username !== undefined && message.username !== "") {
      obj.username = message.username;
    }
    if (message.nickname !== undefined && message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.avatar !== undefined && message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.email !== undefined && message.email !== "") {
      obj.email = message.email;
    }
    if (message.createTime !== undefined && message.createTime !== "") {
      obj.createTime = message.createTime;
    }
    if (message.modifyTime !== undefined && message.modifyTime !== "") {
      obj.modifyTime = message.modifyTime;
    }
    if (message.lastLoginTime !== undefined && message.lastLoginTime !== "") {
      obj.lastLoginTime = message.lastLoginTime;
    }
    if (message.lastLoginIp !== undefined && message.lastLoginIp !== "") {
      obj.lastLoginIp = message.lastLoginIp;
    }
    if (message.loginTotal !== undefined && message.loginTotal !== 0) {
      obj.loginTotal = Math.round(message.loginTotal);
    }
    if (message.enabled !== undefined && message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.token !== undefined && message.token !== "") {
      obj.token = message.token;
    }
    if (message.expire !== undefined && message.expire !== 0) {
      obj.expire = Math.round(message.expire);
    }
    if (message.expireDataTime !== undefined && message.expireDataTime !== "") {
      obj.expireDataTime = message.expireDataTime;
    }
    if (message.menus) {
      const entries = Object.entries(message.menus);
      if (entries.length > 0) {
        obj.menus = {};
        entries.forEach(([k, v]) => {
          obj.menus[k] = MenuItem.toJSON(v);
        });
      }
    }
    if (message.permissions) {
      const entries = Object.entries(message.permissions);
      if (entries.length > 0) {
        obj.permissions = {};
        entries.forEach(([k, v]) => {
          obj.permissions[k] = v;
        });
      }
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => AdminUserRoleItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminInfo>, I>>(base?: I): AdminInfo {
    return AdminInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminInfo>, I>>(object: I): AdminInfo {
    const message = createBaseAdminInfo();
    message.adminId = object.adminId ?? 0;
    message.username = object.username ?? "";
    message.nickname = object.nickname ?? "";
    message.avatar = object.avatar ?? "";
    message.email = object.email ?? "";
    message.createTime = object.createTime ?? "";
    message.modifyTime = object.modifyTime ?? "";
    message.lastLoginTime = object.lastLoginTime ?? "";
    message.lastLoginIp = object.lastLoginIp ?? "";
    message.loginTotal = object.loginTotal ?? 0;
    message.enabled = object.enabled ?? false;
    message.token = object.token ?? "";
    message.expire = object.expire ?? 0;
    message.expireDataTime = object.expireDataTime ?? "";
    message.menus = Object.entries(object.menus ?? {}).reduce<{ [key: string]: MenuItem }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = MenuItem.fromPartial(value);
      }
      return acc;
    }, {});
    message.permissions = Object.entries(object.permissions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.roles = object.roles?.map((e) => AdminUserRoleItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdminInfo_MenusEntry(): AdminInfo_MenusEntry {
  return { key: "", value: undefined };
}

export const AdminInfo_MenusEntry: MessageFns<AdminInfo_MenusEntry> = {
  encode(message: AdminInfo_MenusEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MenuItem.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminInfo_MenusEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminInfo_MenusEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MenuItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminInfo_MenusEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MenuItem.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AdminInfo_MenusEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MenuItem.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminInfo_MenusEntry>, I>>(base?: I): AdminInfo_MenusEntry {
    return AdminInfo_MenusEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminInfo_MenusEntry>, I>>(object: I): AdminInfo_MenusEntry {
    const message = createBaseAdminInfo_MenusEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MenuItem.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAdminInfo_PermissionsEntry(): AdminInfo_PermissionsEntry {
  return { key: "", value: "" };
}

export const AdminInfo_PermissionsEntry: MessageFns<AdminInfo_PermissionsEntry> = {
  encode(message: AdminInfo_PermissionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminInfo_PermissionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminInfo_PermissionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminInfo_PermissionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AdminInfo_PermissionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminInfo_PermissionsEntry>, I>>(base?: I): AdminInfo_PermissionsEntry {
    return AdminInfo_PermissionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminInfo_PermissionsEntry>, I>>(object: I): AdminInfo_PermissionsEntry {
    const message = createBaseAdminInfo_PermissionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
